"""Authentication Functions

The functions on this page authenticate connections and manage TigerGraph credentials.
All functions in this module are called as methods on a link:https://docs.tigergraph.com/pytigergraph/current/core-functions/base[`TigerGraphConnection` object].
"""
# import json
import logging
# import time
# import warnings
# from datetime import datetime
from typing import Union
import httpx

from pyTigerGraph.pyTigerGraphException import TigerGraphException
from pyTigerGraph.pyTigerGraphAuth import pyTigerGraphAuth
from .pyTigerGraphGSQL import AsyncPyTigerGraphGSQL

logger = logging.getLogger(__name__)

# TODO FINISH MAKING THE ASYNCS AND ADD COMMENTS


class AsyncPyTigerGraphAuth(AsyncPyTigerGraphGSQL, pyTigerGraphAuth):

    async def getSecrets(self) -> dict:
        """Issues a `SHOW SECRET` GSQL statement and returns the secret generated by that
            statement.
            Secrets are unique strings that serve as credentials when generating authentication tokens.

        Returns:
            A dictionary of `alias: secret_string` pairs.

        Notes:
            This function returns the masked version of the secret. The original value of the secret cannot
            be retrieved after creation.
        """
        logger.info("entry: getSecrets")

        res = await self.gsql("""
            USE GRAPH {}
            SHOW SECRET""".format(self.graphname), )
        ret = self._parseGetSecrets(res)

        if logger.level == logging.DEBUG:
            logger.debug("return: " + str(ret))
        logger.info("exit: getSecrets")

        return ret
        # TODO Process response, return a dictionary of alias/secret pairs

    async def createSecret(self, alias: str = "", withAlias: bool = False) -> Union[str, dict]:
        """Issues a `CREATE SECRET` GSQL statement and returns the secret generated by that statement.
            Secrets are unique strings that serve as credentials when generating authentication tokens.

        Args:
            alias:
                The alias of the secret. /
                The system will generate a random alias for the secret if the user does not provide
                an alias for that secret. Randomly generated aliases begin with
                `AUTO_GENERATED_ALIAS_` and include a random 7-character string.
            withAlias:
                Return the new secret as an `{"alias": "secret"}` dictionary. This can be useful if
                an alias was not provided, for example if it is auto-generated).

        Returns:
            The secret string.

        Notes:
            Generally, secrets are generated by the database administrator and
            used to generate a token. If you use this function, please consider reviewing your
            internal processes of granting access to TigerGraph instances. Normally, this function
            should not be necessary and should not be executable by generic users.
        """
        logger.info("entry: createSecret")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        res = await self.gsql("""
            USE GRAPH {}
            CREATE SECRET {} """.format(self.graphname, alias))
        secret = self._parseCreateSecret(res, alias=alias, withAlias=withAlias)

        # Alias was not provided, let's find out the autogenerated one
        # done in createSecret since need to call self.getSecrets which is a possibly async function
        if withAlias and not alias:
            masked = secret[:3] + "****" + secret[-3:]
            secs = await self.getSecrets()
            for (a, s) in secs.items():
                if s == masked:
                    secret = {a: secret}

        if logger.level == logging.DEBUG:
            logger.debug("return: " + str(secret))
        logger.info("exit: createSecret")
        return secret

    async def dropSecret(self, alias: Union[str, list], ignoreErrors: bool = True) -> str:
        """Drops a secret.
            See https://docs.tigergraph.com/tigergraph-server/current/user-access/managing-credentials#_drop_a_secret

            Args:
                alias:
                    One or more alias(es) of secret(s).
                ignoreErrors:
                    Ignore errors arising from trying to drop non-existent secrets.

            Raises:
                `TigerGraphException` if a non-existent secret is attempted to be dropped (unless
                `ignoreErrors` is `True`). Re-raises other exceptions.
        """
        logger.info("entry: dropSecret")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        if isinstance(alias, str):
            alias = [alias]
        cmd = """
            USE GRAPH {}""".format(self.graphname)
        for a in alias:
            cmd += """
                DROP SECRET {}""".format(a)
        res = await self.gsql(cmd)
        if "Failed to drop secrets" in res and not ignoreErrors:
            raise TigerGraphException(res)

        if logger.level == logging.DEBUG:
            logger.debug("return: " + str(res))
        logger.info("exit: dropSecret")

        return res

    async def _newToken(self, secret: str = None, lifetime: int = None, token=None, _method=None) -> Union[tuple, str]:
        method, url, alt_url, authMode, data, alt_data = self._prep_newToken(
            secret=secret, lifetime=lifetime, token=token)
        #  _method Used for delete and refresh token

        # method == GET when using old version since _prep_newToken() gets the method for getting a new token for a version
        if method == "GET":
            if _method:
                method = _method

            # Use TG < 3.5 format (no json data)
            res = await self._req(method, url, authMode=authMode, data=data, resKey=None)
            mainVer = 3
        else:
            if _method:
                method = _method

            # Try using TG 4.1 endpoint first, if url not found then try <4.1 endpoint
            try:
                res = await self._req(method, url, authMode=authMode, data=data, resKey=None, jsonData=True)
                mainVer = 4
            except httpx.HTTPError as e:
                if e.response.status_code == 404 or e.response.status_code == 405:
                    res = await self._req(method, alt_url, authMode=authMode, data=alt_data, resKey=None)
                    # res['token'] = res['results']['token'] # bringing token out to outer dict level for consistency, can't just use resKey="results" since want to preserve error message
                    mainVer = 3
                else:
                    raise e

        # uses mainVer instead of _versionGreaterThan4_0 since you need a token for verson checking
        return res, mainVer

    async def newGetToken(self, secret: str = None, setToken: bool = True, lifetime: int = None) -> Union[tuple, str]:
        logger.info("entry: getToken")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        res, mainVer = await self._newToken(secret=secret, lifetime=lifetime)
        token = self._parse_newToken(res, setToken, mainVer)
        logger.info("exit: getToken")
        return token

    async def newRefreshToken(self, secret: str = None, setToken: bool = True, lifetime: int = None, token="") -> Union[tuple, str]:
        logger.info("entry: refreshToken")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        if await self._versionGreaterThan4_0():
            logger.info("exit: refreshToken")
            raise TigerGraphException(
                "Refreshing tokens is only supported on versions of TigerGraph <= 4.0.0.", 0)

        if not token:
            token = self.apiToken
        res, mainVer = await self._newToken(secret=secret, lifetime=lifetime, token=token, _method="PUT")
        newToken = self._parse_newToken(res, setToken, mainVer)
        logger.info("exit: refreshToken")
        return newToken

    async def newDeleteToken(self, secret: str, token=None, skipNA=True) -> bool:
        if not token:
            token = self.apiToken
        res, _ = await self._newToken(secret=secret, token=token, _method="DELETE")

        if not res["error"] or (res["code"] == "REST-3300" and skipNA):
            if logger.level == logging.DEBUG:
                logger.debug("return: " + str(True))
            logger.info("exit: deleteToken")

            return True

        raise TigerGraphException(
            res["message"], (res["code"] if "code" in res else None))
