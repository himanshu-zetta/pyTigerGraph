"""Authentication Functions

The functions on this page authenticate connections and manage TigerGraph credentials.
All functions in this module are called as methods on a link:https://docs.tigergraph.com/pytigergraph/current/core-functions/base[`TigerGraphConnection` object].
"""
import json
import logging
import time
import warnings
from datetime import datetime, timezone
from typing import Union
import inspect

import requests

from pyTigerGraph.pyTigerGraphException import TigerGraphException
from pyTigerGraph.pyTigerGraphGSQL import pyTigerGraphGSQL

logger = logging.getLogger(__name__)


class pyTigerGraphAuth(pyTigerGraphGSQL):

    def _parseGetSecrets(self, res):
        ret = {}
        lines = res.split("\n")
        i = 0
        while i < len(lines):
            l = lines[i]
            s = ""
            if "- Secret" in l:
                s = l.split(": ")[1]
                i += 1
                l = lines[i]
                if "- Alias" in l:
                    ret[l.split(": ")[1]] = s
            i += 1
        return ret

    def getSecrets(self) -> dict:
        """Issues a `SHOW SECRET` GSQL statement and returns the secret generated by that
            statement.
            Secrets are unique strings that serve as credentials when generating authentication tokens.

        Returns:
            A dictionary of `alias: secret_string` pairs.

        Notes:
            This function returns the masked version of the secret. The original value of the secret cannot
            be retrieved after creation.
        """
        logger.info("entry: getSecrets")

        res = self.gsql("""
            USE GRAPH {}
            SHOW SECRET""".format(self.graphname), )
        ret = self._parseGetSecrets(res)

        if logger.level == logging.DEBUG:
            logger.debug("return: " + str(ret))
        logger.info("exit: getSecrets")

        return ret
        # TODO Process response, return a dictionary of alias/secret pairs

    def showSecrets(self) -> dict:
        """DEPRECATED

        Use `getSecrets()` instead.
        """
        warnings.warn("The `showSecrets()` function is deprecated; use `getSecrets()` instead.",
                      DeprecationWarning)

        return self.getSecrets()

    # TODO getSecret()

    def _parseCreateSecret(self, res, alias: str = "", withAlias: bool = False):
        try:
            if ("already exists" in res):
                errorMsg = "The secret "
                if alias != "":
                    errorMsg += "with alias {} ".format(alias)
                errorMsg += "already exists."
                raise TigerGraphException(errorMsg, "E-00001")

            secret = "".join(res).replace('\n', '').split(
                'The secret: ')[1].split(" ")[0].strip()

            if not withAlias:
                if logger.level == logging.DEBUG:
                    logger.debug("return: " + str(secret))
                logger.info("exit: createSecret (withAlias")

                return secret

            if alias:
                ret = {alias: secret}

                if logger.level == logging.DEBUG:
                    logger.debug("return: " + str(ret))
                logger.info("exit: createSecret (alias)")

                return ret

            return secret

        except:
            raise

    def createSecret(self, alias: str = "", withAlias: bool = False) -> Union[str, dict]:
        """Issues a `CREATE SECRET` GSQL statement and returns the secret generated by that statement.
            Secrets are unique strings that serve as credentials when generating authentication tokens.

        Args:
            alias:
                The alias of the secret. /
                The system will generate a random alias for the secret if the user does not provide
                an alias for that secret. Randomly generated aliases begin with
                `AUTO_GENERATED_ALIAS_` and include a random 7-character string.
            withAlias:
                Return the new secret as an `{"alias": "secret"}` dictionary. This can be useful if
                an alias was not provided, for example if it is auto-generated).

        Returns:
            The secret string.

        Notes:
            Generally, secrets are generated by the database administrator and
            used to generate a token. If you use this function, please consider reviewing your
            internal processes of granting access to TigerGraph instances. Normally, this function
            should not be necessary and should not be executable by generic users.
        """
        logger.info("entry: createSecret")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        res = self.gsql("""
            USE GRAPH {}
            CREATE SECRET {} """.format(self.graphname, alias))
        secret = self._parseCreateSecret(res, alias=alias, withAlias=withAlias)

        # Alias was not provided, let's find out the autogenerated one
        # done in createSecret since need to call self.getSecrets which is a possibly async function
        if withAlias and not alias:
            masked = secret[:3] + "****" + secret[-3:]
            secs = self.getSecrets()
            for (a, s) in secs.items():
                if s == masked:
                    secret = {a: secret}

        if logger.level == logging.DEBUG:
            logger.debug("return: " + str(secret))
        logger.info("exit: createSecret")
        return secret

    def dropSecret(self, alias: Union[str, list], ignoreErrors: bool = True) -> str:
        """Drops a secret.
            See https://docs.tigergraph.com/tigergraph-server/current/user-access/managing-credentials#_drop_a_secret

            Args:
                alias:
                    One or more alias(es) of secret(s).
                ignoreErrors:
                    Ignore errors arising from trying to drop non-existent secrets.

            Raises:
                `TigerGraphException` if a non-existent secret is attempted to be dropped (unless
                `ignoreErrors` is `True`). Re-raises other exceptions.
        """
        logger.info("entry: dropSecret")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        if isinstance(alias, str):
            alias = [alias]
        cmd = """
            USE GRAPH {}""".format(self.graphname)
        for a in alias:
            cmd += """
                DROP SECRET {}""".format(a)
        res = self.gsql(cmd)
        if "Failed to drop secrets" in res and not ignoreErrors:
            raise TigerGraphException(res)

        if logger.level == logging.DEBUG:
            logger.debug("return: " + str(res))
        logger.info("exit: dropSecret")

        return res

    def _prep_newToken(self, secret: str = None, lifetime: int = None, token=None, method=None):
        # builds url and parameters for requesting get, refresh, and delete token

        # Endpoint changed in TG 3.5 (I guess? actually unsure...Written by poor intern refactoring ugly code...)
        # TODO: Test this on TG ver <3.5
        s, m, i = (0, 0, 0)
        if self.version:
            s, m, i = self.version.split(".")
        if 0 < int(s) < 3 or (int(s) == 3 and int(m) < 5):
            method = "GET"
            url = self.restppUrl + "/requesttoken?secret=" + secret + \
                ("&lifetime=" + str(lifetime) if lifetime else "") + \
                ("&token=" + token if token else "")
            authMode = None
            if not secret:
                raise TigerGraphException(
                    "Cannot request a token with username/password for versions < 3.5.")
        else:
            method = "POST"
            url = self.gsUrl + "/gsql/v1/tokens"  # used for TG 4.x
            data = {"graph": self.graphname}

            # alt_url and alt_data used to construct the method and url for functions run in TG version 3.x
            alt_url = self.restppUrl+"/requesttoken"  # used for TG 3.x
            alt_data = {}
            if lifetime:
                data["lifetime"] = str(lifetime)
                alt_data["lifetime"] = str(lifetime)
            if token:
                data["tokens"] = token
                alt_data["token"] = token
            if secret:
                authMode = "None"
                data["secret"] = secret
                alt_data["secret"] = secret
                alt_data = json.dumps(alt_data)
            else:
                authMode = "pwd"
                alt_data = str(alt_data)
        return method, url, alt_url, authMode, data, alt_data

    def _parse_newToken(self, res, setToken, mainVer):
        if not res.get("error"):
            if setToken:
                self.apiToken = res["token"]
                self.authHeader = {'Authorization': "Bearer " + self.apiToken}
            else:
                self.apiToken = None
                self.authHeader = {
                    'Authorization': 'Basic {0}'.format(self.base64_credential)}

            if res.get("expiration"):
                # On >=4.1 the format for the date of expiration changed. Convert back to old format
                # Can't use self._versionGreaterThan4_0 since you need a token for that
                if mainVer == 4:
                    ret = res["token"], res.get("expiration")
                else:
                    ret = res["token"], res.get("expiration"), \
                        datetime.utcfromtimestamp(
                            float(res.get("expiration"))).strftime('%Y-%m-%d %H:%M:%S')
            else:
                ret = res["token"]
            return ret

        if "Endpoint is not found from url = /requesttoken" in res["message"]:
            raise TigerGraphException("REST++ authentication is not enabled, can't generate token.",
                                      None)
        raise TigerGraphException(
            res["message"], (res["code"] if "code" in res else None))

    def _newToken(self, secret: str = None, lifetime: int = None, token=None, _method=None) -> Union[tuple, str]:
        method, url, alt_url, authMode, data, alt_data = self._prep_newToken(
            secret=secret, lifetime=lifetime, token=token)
        #  _method Used for delete and refresh token

        # method == GET when using old version since _prep_newToken() gets the method for getting a new token for a version
        if method == "GET":
            if _method:
                method = _method

            # Use TG < 3.5 format (no json data)
            res = self._req(method, url, authMode=authMode,
                            data=data, resKey=None)
            mainVer = 3
        else:
            if _method:
                method = _method

            # Try using TG 4.1 endpoint first, if url not found then try <4.1 endpoint
            try:
                res = self._req(method, url, authMode=authMode,
                                data=data, resKey=None, jsonData=True)
                mainVer = 4
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 404 or e.response.status_code == 405:
                    res = self._req(
                        method, alt_url, authMode=authMode, data=alt_data, resKey=None)
                    # res['token'] = res['results']['token'] # bringing token out to outer dict level for consistency, can't just use resKey="results" since want to preserve error message
                    mainVer = 3
                else:
                    raise e

        # uses mainVer instead of _versionGreaterThan4_0 since you need a token for verson checking
        return res, mainVer

    def newGetToken(self, secret: str = None, setToken: bool = True, lifetime: int = None) -> Union[tuple, str]:
        logger.info("entry: getToken")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        res, mainVer = self._newToken(secret=secret, lifetime=lifetime)
        token = self._parse_newToken(res, setToken, mainVer)
        logger.info("exit: getToken")
        return token

    def newRefreshToken(self, secret: str = None, setToken: bool = True, lifetime: int = None, token="") -> Union[tuple, str]:
        logger.info("entry: refreshToken")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        if self._versionGreaterThan4_0():
            logger.info("exit: refreshToken")
            raise TigerGraphException(
                "Refreshing tokens is only supported on versions of TigerGraph <= 4.0.0.", 0)

        if not token:
            token = self.apiToken
        res, mainVer = self._newToken(
            secret=secret, lifetime=lifetime, token=token, _method="PUT")
        newToken = self._parse_newToken(res, setToken, mainVer)
        logger.info("exit: refreshToken")
        return newToken

    def newDeleteToken(self, secret: str, token=None, skipNA=True) -> bool:
        if not token:
            token = self.apiToken
        res, _ = self._newToken(secret=secret, token=token, _method="DELETE")

        if not res["error"] or (res["code"] == "REST-3300" and skipNA):
            if logger.level == logging.DEBUG:
                logger.debug("return: " + str(True))
            logger.info("exit: deleteToken")

            return True

        raise TigerGraphException(
            res["message"], (res["code"] if "code" in res else None))

    def getToken(self, secret: str = None, setToken: bool = True, lifetime: int = None) -> Union[tuple, str]:
        """Requests an authorization token.

        This function returns a token only if REST++ authentication is enabled. If not, an exception
        will be raised.
        See https://docs.tigergraph.com/admin/admin-guide/user-access-management/user-privileges-and-authentication#rest-authentication

        Args:
            secret (str, Optional):
                The secret (string) generated in GSQL using `CREATE SECRET`.
                See https://docs.tigergraph.com/tigergraph-server/current/user-access/managing-credentials#_create_a_secret
            setToken (bool, Optional):
                Set the connection's API token to the new value (default: `True`).
            lifetime (int, Optional):
                Duration of token validity (in seconds, default 30 days = 2,592,000 seconds).

        Returns:
            If your TigerGraph instance is running version <=3.10, the return value is 
            a tuple of `(<token>, <expiration_timestamp_unixtime>, <expiration_timestamp_ISO8601>)`.
            The return value can be ignored, as the token is automatically set for the connection after this call.

            If your TigerGraph instance is running version 4.0, the return value is a tuple of `(<token>, <expiration_timestamp_with_local_time>).

            [NOTE]
            The expiration timestamp's time zone might be different from your computer's local time
            zone.

        Raises:
            `TigerGraphException` if REST++ authentication is not enabled or if an authentication
            error occurred.

        Endpoint:
            - `POST /requesttoken` (In TigerGraph versions 3.x)
                See https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_request_a_token
            - `POST /gsql/v1/tokens` (In TigerGraph versions 4.x)
        """
        logger.info("entry: getToken")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        s, m, i = (0, 0, 0)
        res = {}
        if self.version:
            s, m, i = self.version.split(".")
        success = False

        if secret and (int(s) < 3 or (int(s) == 3 and int(m) < 5)):
            try:
                # /gsql/v1/tokens endpoint only supported on version >=4.1 and replaced /requesttoken
                _json = {"secret": secret, "graph": self.graphname}
                if lifetime:
                    _json["lifetime"] = str(lifetime)
                res = self._req("POST", self.gsUrl +
                                "/gsql/v1/tokens", data=_json, jsonData=True, resKey=None)

                # if /gsql/v1/tokens endpoint doesn't exist then try old endpoint
                if res.status_code == 404:
                    res = self._req("GET", self.restppUrl +
                                    "/requesttoken?secret=" + secret +
                                    ("&lifetime=" + str(lifetime) if lifetime else ""), verify=False)
                    mainVer = 3  # Can't use _verGreaterThan4_0 to check version since you need to set a token for that
                else:
                    mainVer = 4
                res = json.loads(res.text)

                if not res["error"]:
                    success = True
            except Exception as e:
                raise e

        elif not (success) and not (secret) and mainVer == 3:
            res = self._req("POST", self.restppUrl+"/requesttoken", authMode="pwd",
                            data=str({"graph": self.graphname}), resKey="results")

        elif not(success) and not(secret):
            _json = {"graph": self.graphname}
            try:
                res = self._post(self.gsUrl +
                    "/gsql/v1/tokens", data=_json, authMode="pwd", jsonData=True, resKey=None)
                mainVer = 4
                
            # The new endpoint doesn't exist (since on TigerGraph Ver <4.1). Use old endpoint
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 404:    
                    res = self._post(self.restppUrl+"/requesttoken", authMode="pwd", data=str({"graph": self.graphname}), resKey="results")
                    mainVer = 3
                else:
                    raise e

            success = True
        elif not (success) and (int(s) < 3 or (int(s) == 3 and int(m) < 5)):
            raise TigerGraphException(
                "Cannot request a token with username/password for versions < 3.5.")


        if not success and mainVer == 3:  # can't use _verGreaterThan4_0 bc haven't set the token yet
            try:
                data = {"secret": secret}

                if lifetime:
                    data["lifetime"] = str(lifetime)

                res = json.loads(requests.post(self.restppUrl + "/requesttoken",
                                               data=json.dumps(data), verify=False).text)
            except Exception as e:
                raise e

        if not res.get("error"):
            if setToken:
                self.apiToken = res["token"]
                self.authHeader = {'Authorization': "Bearer " + self.apiToken}
            else:
                self.apiToken = None
                self.authHeader = {
                    'Authorization': 'Basic {0}'.format(self.base64_credential)}

            if res.get("expiration"):
                # On >=4.1 the format for the date of expiration changed, can't get utc time stamp from it
                if mainVer == 4:
                    ret = res["token"], res.get("expiration")
                else:
                    ret = res["token"], res.get("expiration"), \
                        datetime.utcfromtimestamp(
                            float(res.get("expiration"))).strftime('%Y-%m-%d %H:%M:%S')
            else:
                ret = res["token"]

            if logger.level == logging.DEBUG:
                logger.debug("return: " + str(ret))
            logger.info("exit: getToken")

            return ret

        if "Endpoint is not found from url = /requesttoken" in res["message"]:
            raise TigerGraphException("REST++ authentication is not enabled, can't generate token.",
                                      None)
        raise TigerGraphException(
            res["message"], (res["code"] if "code" in res else None))

    def refreshToken(self, secret: str, token: str = "", setToken: bool = True, lifetime: int = None) -> tuple:
        """Extends a token's lifetime.

        This function works only if REST++ authentication is enabled. If not, an exception will be
        raised.
        See https://docs.tigergraph.com/admin/admin-guide/user-access-management/user-privileges-and-authentication#rest-authentication

        Args:
            secret:
                The secret (string) generated in GSQL using `CREATE SECRET`.
                See https://docs.tigergraph.com/tigergraph-server/current/user-access/managing-credentials#_create_a_secret
            token:
                The token requested earlier. If not specified, refreshes current connection's token.
            lifetime:
                Duration of token validity (in seconds, default 30 days = 2,592,000 seconds) from
                current system timestamp.

        Returns:
            A tuple of `(<token>, <expiration_timestamp_unixtime>, <expiration_timestamp_ISO8601>)`.
            The return value can be ignored. /
            New expiration timestamp will be now + lifetime seconds, _not_ current expiration
            timestamp + lifetime seconds.

            [NOTE]
            The expiration timestamp's time zone might be different from your computer's local time
            zone.


        Raises:
            `TigerGraphException` if REST++ authentication is not enabled, if an authentication error
            occurs, or if calling while using TigerGraph 4.x.

        Note:
            Not avaliable on TigerGraph version 4.x

        Endpoint:
            - `PUT /requesttoken`
                See https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_refresh_a_token
        TODO Rework lifetime parameter handling the same as in getToken()
        """
        logger.info("entry: refreshToken")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        s, m, i = (0, 0, 0)
        res = {}
        if self.version:
            s, m, i = self.version.split(".")
        success = False

        if not token:
            token = self.apiToken

        if self._versionGreaterThan4_0():
            logger.info("exit: refreshToken")
            raise TigerGraphException(
                "Refreshing tokens is only supported on versions of TigerGraph <= 4.0.0.", 0)

        if int(s) < 3 or (int(s) == 3 and int(m) < 5):
            if self.useCert and self.certPath:
                res = json.loads(requests.request("PUT", self.restppUrl + "/requesttoken?secret=" +
                                                  secret + "&token=" + token +
                                                  ("&lifetime=" + str(lifetime)
                                                   if lifetime else ""),
                                                  verify=False).text)
            else:
                res = json.loads(requests.request("PUT", self.restppUrl + "/requesttoken?secret=" +
                                                  secret + "&token=" + token +
                                                  ("&lifetime=" + str(lifetime)
                                                   if lifetime else "")
                                                  ).text)

            if not res["error"]:
                success = True
            if "Endpoint is not found from url = /requesttoken" in res["message"]:
                raise TigerGraphException("REST++ authentication is not enabled, can't refresh token.",
                                          None)

        if not success:
            data = {"secret": secret, "token": token}
            if lifetime:
                data["lifetime"] = str(lifetime)
            if self.useCert is True and self.certPath is not None:
                res = json.loads(requests.put(self.restppUrl + "/requesttoken",
                                              data=json.dumps(data), verify=False).text)
            else:
                res = json.loads(requests.put(self.restppUrl + "/requesttoken",
                                              data=json.dumps(data), verify=False).text)

            if not res["error"]:
                success = True
            if "Endpoint is not found from url = /requesttoken" in res["message"]:
                raise TigerGraphException("REST++ authentication is not enabled, can't refresh token.",
                                          None)

        if success:
            exp = time.time() + res["expiration"]
            ret = res["token"], int(exp), \
                datetime.fromtimestamp(exp, timezone.utc).strftime('%Y-%m-%d %H:%M:%S')

            if logger.level == logging.DEBUG:
                logger.debug("return: " + str(ret))
            logger.info("exit: refreshToken")

            return ret

        raise TigerGraphException(
            res["message"], (res["code"] if "code" in res else None))

    def deleteToken(self, secret, token=None, skipNA=True) -> bool:
        """Deletes a token.

        This function works only if REST++ authentication is enabled. If not, an exception will be
        raised.
        See https://docs.tigergraph.com/tigergraph-server/current/user-access/enabling-user-authentication#_enable_restpp_authentication

        Args:
            secret:
                The secret (string) generated in GSQL using `CREATE SECRET`.
                See https://docs.tigergraph.com/tigergraph-server/current/user-access/managing-credentials#_create_a_secret
            token:
                The token requested earlier. If not specified, deletes current connection's token,
                so be careful.
            skipNA:
                Don't raise an exception if the specified token does not exist.

        Returns:
            `True`, if deletion was successful, or if the token did not exist but `skipNA` was
            `True`.

        Raises:
            `TigerGraphException` if REST++ authentication is not enabled or an authentication error
            occurred, for example if the specified token does not exist.

        Endpoint:
            - `DELETE /requesttoken` (In TigerGraph version 3.x)
                See https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_delete_a_token
            - `DELETE /gsql/v1/tokens` (In TigerGraph version 4.x)
        """
        logger.info("entry: deleteToken")
        if logger.level == logging.DEBUG:
            logger.debug("params: " + self._locals(locals()))

        s, m, i = (0, 0, 0)
        res = {}
        if self.version:
            s, m, i = self.version.split(".")
        success = False

        if not token:
            token = self.apiToken

        if int(s) < 3 or (int(s) == 3 and int(m) < 5):
            if self.useCert is True and self.certPath is not None:
                if self._versionGreaterThan4_0():
                    res = requests.request("DELETE", self.gsUrl +
                                           "/gsql/v1/tokens", verify=False, json={"secret": secret, "token": token},
                                           headers={"X-User-Agent": "pyTigerGraph"})
                    res = json.loads(res.text)
                else:
                    res = json.loads(
                        requests.request("DELETE",
                                         self.restppUrl + "/requesttoken?secret=" + secret + "&token=" + token,
                                         verify=False).text)
            else:
                if self._versionGreaterThan4_0():
                    res = requests.request("DELETE", self.gsUrl +
                                           "/gsql/v1/tokens", verify=False, json={"tokens": token},
                                           headers={"X-User-Agent": "pyTigerGraph"})
                    res = json.loads(res.text)
                else:
                    res = json.loads(
                        requests.request("DELETE",
                                         self.restppUrl + "/requesttoken?secret=" + secret + "&token=" + token).text)
            if not res["error"]:
                success = True

        if not success:
            data = {"secret": secret, "token": token}
            if self.useCert is True and self.certPath is not None:
                res = json.loads(requests.delete(self.restppUrl + "/requesttoken",
                                                 data=json.dumps(data)).text)
            else:
                if self._versionGreaterThan4_0():
                    res = requests.request("DELETE", self.gsUrl +
                                           "/gsql/v1/tokens", verify=False, data=json.dumps(data),
                                           headers={"X-User-Agent": "pyTigerGraph"})
                    res = json.loads(res.text)
                else:
                    res = json.loads(requests.delete(self.restppUrl + "/requesttoken",
                                                     data=json.dumps(data), verify=False).text)

        if "Endpoint is not found from url = /requesttoken" in res["message"]:
            raise TigerGraphException("REST++ authentication is not enabled, can't delete token.",
                                      None)

        if not res["error"]:
            if logger.level == logging.DEBUG:
                logger.debug("return: " + str(True))
            logger.info("exit: deleteToken")

            return True

        if res["code"] == "REST-3300" and skipNA:
            if logger.level == logging.DEBUG:
                logger.debug("return: " + str(True))
            logger.info("exit: deleteToken")

            return True

        raise TigerGraphException(
            res["message"], (res["code"] if "code" in res else None))
